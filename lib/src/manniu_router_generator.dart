import 'dart:async';

import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/constant/value.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';

/// <pre>
/// Used to  路由生成器！
/// <pre/>
/// created by:   yaochunfeng
/// on:           2021/11/24 9:45 上午
/// Email:        yaochunfeng@wondersgroup.com

class _MNRouteItem {
  String? className;
  List<String>? tags;
  Map<String, String?>? options;
  _MNRouteItem(this.className, {this.tags, this.options});
}
class RouteGenerator extends ControlableBuilder {
  final BuilderOptions options;
  final String extension;

  RouteGenerator(this.options, {required this.extension});

  static const String RouteMapFileExtention = ".manniu.dart";
  static const String _header = '''
/// ====== Generated by Manniu Router! ======
/// ====== Do not modified it!!!       ======
  ''';
  Map<String, _MNRouteItem> routerMap = Map();
  List<String> importList = <String>[];

  Future<bool> _hasAnyTopLevelAnnotations(
      AssetId input, Resolver resolver, BuildStep buildStep) async {
    if (!await buildStep.canRead(input)) return false;
    final parsed = await resolver.compilationUnitFor(input);
    final partIds = <AssetId>[];
    for (var directive in parsed.directives) {
      if (directive.metadata.isNotEmpty) return true;
      if (directive is PartDirective) {
        partIds.add(
          AssetId.resolve(Uri.parse(directive.uri.stringValue!), from: input),
        );
      }
    }
    for (var declaration in parsed.declarations) {
      if (declaration.metadata.isNotEmpty) return true;
    }
    for (var partId in partIds) {
      if (await _hasAnyTopLevelAnnotations(partId, resolver, buildStep)) {
        return true;
      }
    }
    return false;
  }


  @override
  FutureOr<void> build(BuildStep buildStep) async {
    final resolver = buildStep.resolver;
    //排除那些不需要跑的（没有注解的）
    if (!(await _hasAnyTopLevelAnnotations(
        buildStep.inputId, resolver, buildStep))) {
      return;
    }

    LibraryElement libraryElement = await buildStep.resolver
        .libraryFor(buildStep.inputId, allowSyntaxErrors: false);
    Iterable<Element> allElements = libraryElement.topLevelElements;
    for (var element in allElements) {
      if (!(element is ClassElement)) {
        return;
      }
      for (ElementAnnotation annotation in element.metadata) {
        DartObject? obj = annotation.computeConstantValue();
        if (obj == null) {
          continue;
        }
        var rootMapMarkItem = obj.getField("isRouteMap");
        var pageNameItem = obj.getField("pageName");
        var pathItem = obj.getField("path");

        if (rootMapMarkItem != null) {
          bool isRootMap = rootMapMarkItem.toBoolValue() ?? false;
          //是否是根路由
          if (isRootMap) {
            writeOutput(
                buildStep, extension, getContent(importList, routerMap));
            //这边要return整个流程
            return;
          } else {
            String className = element.displayName;
            String pageName = "";
            if (pageNameItem != null) {
              pageName = pageNameItem.toStringValue() ?? "";
            }
            if (pathItem != null) {
              String? path = pathItem.toStringValue();
              if (path == null || path.trim() == "") {
                log.warning('Error : ${className}: 不支持路由地址为空！！！');
                throw Exception('${className}: 不支持路由地址为空！！！');
              }
              log.info(
                  '\n==> Found New Route: ==> Path：${path} ==> Class: ${className}${(pageName == null || pageName.trim() == "") ? "" : "==> PageName:" + pageName}'
              );
              List<String> tags = [];
              obj.getField("tags")?.toListValue()?.forEach((element) {
                String? tmp= element.toStringValue();
                if(tmp != null){
                  tags.add(getSafeString(tmp));
                }
              });

              Map<String, String?> options = Map();
              obj.getField("options")?.toMapValue()?.forEach((key, value) {
                String? tmpKey = key?.toStringValue();
                String? tmpValue = value?.toStringValue();
                if(tmpKey != null){
                  if(tmpValue != null) {
                    options[getSafeString(tmpKey)] = getSafeString(tmpValue);
                  }
                }
              });

              //记录路径和被注解的类的类型
              routerMap[path] = _MNRouteItem(className, tags: tags, options: options);
              // if (element.constructors.length > 0) {
              //   log.info('constructors displayName = ${element.constructors.first.displayName}');
              //   log.info('constructors name = ${element.constructors.first.name}');
              //   log.info('constructors type.parameters = ${element.constructors.first.type.parameters.first.type.name}');
              // }
              if (buildStep.inputId.path.contains('lib/')) {
                importList.add(
                    "package:${buildStep.inputId.package}/${buildStep.inputId.path.replaceFirst('lib/', '')}");
              } else {
                importList.add("${buildStep.inputId.path}");
              }
            }
          }
        }
      }
    }
  }

  Future<void> writeOutput(
      BuildStep buildStep, String extension, String content) async {
    final outputId = buildStep.inputId.changeExtension(extension);
    final contentBuffer = StringBuffer();

    if (_header.isNotEmpty) {
      contentBuffer.writeln(_header);
    }

    contentBuffer..writeln(content);

    var genPartContent = contentBuffer.toString();

    await buildStep.writeAsString(outputId, genPartContent);
  }

  @override
  Future<Iterable<AssetId>> manualRunBuilder(int phaseNumber,
      Set<AssetId> primaryInputs, BuilderRunner builderRunner) async {
    Set<AssetId> handleSet = Set();
    Set<AssetId> lastSet = Set();
    Set<AssetId> result = Set();
    primaryInputs.forEach((element) {
      if (element.path.endsWith(RouteMapFileExtention)) {
        lastSet.add(element);
      } else {
        handleSet.add(element);
      }
    });
    //运行第二块
    if (lastSet.length > 0) {
      //运行第一块
      result.addAll(await builderRunner(phaseNumber, handleSet));
      result.addAll(await builderRunner(phaseNumber, lastSet));
    } else {
      log.warning('******当前模块未定义路由表输出文件！将不会在当前模块输出路由表！******');
      log.warning('******正确的路由表的后缀名："' + RouteMapFileExtention + '"******');
    }
    return result;
  }

  @override
  Map<String, List<String>> get buildExtensions => {
        '.dart': [
          ".route.g.dart",
        ]
      };

  String getSafeString(String value){
    if(value.contains("'")){
      return '"${value}"';
    }else{
      return "'${value}'";
    }
  }

  ///处理模板（替换占位符号为指定内容）
  String handleTemplete(String tpl, Map<String, String> map) {
    String result = tpl;
    map.forEach((String key, String value) {
      result = result.replaceAll('{{{${key}}}}', value);
    });
    return result;
  }

  String getContent(List<String> importList, Map<String, _MNRouteItem> routerMap) {
    String importBlock = '';
    importList.forEach((String path) {
      importBlock += '\nimport \'${path}\';';
    });
    return handleTemplete(clazzTpl, <String, String>{
      'import_block': importBlock,
      'routerMap': routerMap.map((String key, _MNRouteItem element) {
        return MapEntry('\n\t\'${key}\'', handleTemplete(mnRouteItemInstanceTpl, <String, String>{
          "className": '() => ${element.className}()',
          "tags": (element.tags == null || element.tags!.length < 1) ? "" : ", tags: ${element.tags}",
          "options": (element.options == null || element.options!.length < 1) ? "" : ", options: ${element.options}",
        }));
      }).toString()
    });
  }
}

const String mnRouteItemInstanceTpl = """
MNRouterItem({{{className}}}{{{tags}}}{{{options}}})
""";


const String clazzTpl = """
{{{import_block}}}
import 'package:flutter/widgets.dart';
import 'package:manniu_router/manniu_router.dart';

class MNRouterImpl{
  MNRouterImpl._();
  static Map<String, MNRouterItem> get routerMap => _routerMap;
  static final Map<String, MNRouterItem> _routerMap =
      <String, MNRouterItem>{{{routerMap}}};

  static bool hasPage(String path) {
    return _routerMap.containsKey(path);
  }

  static Widget? makePage(String path) {
    return _routerMap[path]?.creator();
  }
}

""";

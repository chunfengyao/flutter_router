import 'dart:async';

import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/constant/value.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';

/// <pre>
/// Used to  路由生成器！
/// <pre/>
/// created by:   yaochunfeng
/// on:           2021/11/24 9:45 上午
/// Email:        yaochunfeng@wondersgroup.com

class RouteGenerator extends ControlableBuilder {
  final BuilderOptions options;
  final String extension;

  RouteGenerator(this.options, {required this.extension});

  static const String RouteMapFileExtention = ".route.manniu.dart";
  static const String _header = '''
/// ====== Generated by Manniu Router! ======
/// ====== Do not modified it!!!       ======
  ''';
  Map<String, String> routerMap = <String, String>{};
  List<String> importList = <String>[];

  Future<bool> _hasAnyTopLevelAnnotations(
      AssetId input, Resolver resolver, BuildStep buildStep) async {
    if (!await buildStep.canRead(input)) return false;
    final parsed = await resolver.compilationUnitFor(input);
    final partIds = <AssetId>[];
    for (var directive in parsed.directives) {
      if (directive.metadata.isNotEmpty) return true;
      if (directive is PartDirective) {
        partIds.add(
          AssetId.resolve(Uri.parse(directive.uri.stringValue!), from: input),
        );
      }
    }
    for (var declaration in parsed.declarations) {
      if (declaration.metadata.isNotEmpty) return true;
    }
    for (var partId in partIds) {
      if (await _hasAnyTopLevelAnnotations(partId, resolver, buildStep)) {
        return true;
      }
    }
    return false;
  }


  @override
  FutureOr<void> build(BuildStep buildStep) async {
    final resolver = buildStep.resolver;
    //排除那些不需要跑的（没有注解的）
    if (!(await _hasAnyTopLevelAnnotations(
        buildStep.inputId, resolver, buildStep))) {
      return;
    }

    LibraryElement libraryElement = await buildStep.resolver
        .libraryFor(buildStep.inputId, allowSyntaxErrors: false);
    Iterable<Element> allElements = libraryElement.topLevelElements;
    for (var element in allElements) {
      if (!(element is ClassElement)) {
        return;
      }
      for (ElementAnnotation annotation in element.metadata) {
        DartObject? obj = annotation.computeConstantValue();
        if (obj == null) {
          continue;
        }
        var rootMapMarkItem = obj.getField("isRouteMap");
        var pageNameItem = obj.getField("pageName");
        var pathItem = obj.getField("path");

        if (rootMapMarkItem != null) {
          bool isRootMap = rootMapMarkItem.toBoolValue() ?? false;
          //是否是根路由
          if (isRootMap) {
            // writeOutput(
            //     buildStep, extension, getContent(importList, routerMap));
            //TODO 这边要return整个流程
            return;
          } else {
            String className = element.displayName;
            String pageName = "";
            if (pageNameItem != null) {
              pageName = pageNameItem.toStringValue() ?? "";
            }
            if (pathItem != null) {
              String? path = pathItem.toStringValue();
              if (path == null || path.trim() == "") {
                log.warning('Error : ${className}: 不支持路由地址为空！！！');
                throw Exception('${className}: 不支持路由地址为空！！！');
              }
              log.info(
                  '\n==> Found New Route: ==> Path：${path} ==> Class: ${className}${(pageName == null || pageName.trim() == "") ? "" : "==> PageName:" + pageName}'
              );
              //记录路径和被注解的类的类型
              routerMap[path] = className;
              // if (element.constructors.length > 0) {
              //   log.info('constructors displayName = ${element.constructors.first.displayName}');
              //   log.info('constructors name = ${element.constructors.first.name}');
              //   log.info('constructors type.parameters = ${element.constructors.first.type.parameters.first.type.name}');
              // }
              if (buildStep.inputId.path.contains('lib/')) {
                importList.add(
                    "package:${buildStep.inputId.package}/${buildStep.inputId.path.replaceFirst('lib/', '')}");
              } else {
                importList.add("${buildStep.inputId.path}");
              }
            }
          }
        }
      }
    }
  }

  Future<void> writeOutput(
      BuildStep buildStep, String extension, String content) async {
    final outputId = buildStep.inputId.changeExtension(extension);
    final contentBuffer = StringBuffer();

    if (_header.isNotEmpty) {
      contentBuffer.writeln(_header);
    }

    contentBuffer..writeln(content);

    var genPartContent = contentBuffer.toString();

    await buildStep.writeAsString(outputId, genPartContent);
  }

  @override
  Future<Iterable<AssetId>> manualRunBuilder(int phaseNumber,
      Set<AssetId> primaryInputs, BuilderRunner builderRunner) async {
    Set<AssetId> handleSet = Set();
    Set<AssetId> lastSet = Set();
    Set<AssetId> result = Set();
    primaryInputs.forEach((element) {
      if (element.path.endsWith(RouteMapFileExtention)) {
        lastSet.add(element);
      } else {
        handleSet.add(element);
      }
    });
    //运行第二块
    if (lastSet.length > 0) {
      //运行第一块
      result.addAll(await builderRunner(phaseNumber, handleSet));
      result.addAll(await builderRunner(phaseNumber, lastSet));
    } else {
      log.warning('******当前模块未定义路由表输出文件！将不会在当前模块输出路由表！******');
      log.warning('******正确的路由表的后缀名："' + RouteMapFileExtention + '"******');
    }
    return result;
  }

  @override
  Map<String, List<String>> get buildExtensions => {
        '.dart': [
          ".g.dart",
        ]
      };

  ///处理模板（替换占位符号为指定内容）
  String handleTemplete(Map<String, String> map) {
    String result = clazzTpl;
    map.forEach((String key, String value) {
      result = result.replaceAll('{{{${key}}}}', value);
    });
    return result;
  }

  String getContent(List<String> importList, Map<String, String> routerMap) {
    String importBlock = '';
    importList.forEach((String path) {
      importBlock += '\nimport \'${path}\';';
    });
    return handleTemplete(<String, String>{
      'import_block': importBlock,
      'routerMap': routerMap.map((String key, dynamic element) {
        return MapEntry('\n\t\'${key}\'', '() => ${element}()');
      }).toString()
    });
  }
}

const String clazzTpl = """
{{{import_block}}}
import 'package:flutter/widgets.dart';
import 'package:manniu_router/manniu_router.dart';

class MNRouterImpl{
  MNRouterImpl._();
  static Map<String, MNRouterCreatePage> get routerMap => _routerMap;
  static final Map<String, MNRouterCreatePage> _routerMap =
      <String, MNRouterCreatePage>{{{routerMap}}};

  static bool hasPage(String path) {
    return _routerMap.containsKey(path);
  }

  static Widget? findPage(String path) {
    MNRouterCreatePage? func;
    if((func = _routerMap[path]) != null) {
      return func!();
    }else{
      return null;
    }
  }
}

""";
